<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--
   Copyright (c) 2005, 2017 IBM Corp. and others

   This program and the accompanying materials are made available under
   the terms of the Eclipse Public License 2.0 which accompanies this
   distribution and is available at https://www.eclipse.org/legal/epl-2.0/
   or the Apache License, Version 2.0 which accompanies this distribution and
   is available at https://www.apache.org/licenses/LICENSE-2.0.

   This Source Code may also be made available under the following
   Secondary Licenses when the conditions for such availability set
   forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
   General Public License, version 2 with the GNU Classpath
   Exception [1] and GNU General Public License, version 2 with the
   OpenJDK Assembly Exception [2].

   [1] https://www.gnu.org/software/classpath/license.html
   [2] http://openjdk.java.net/legal/assembly-exception.html

   SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
-->
<html lang="en-us">
<head> 
  <title>Modron Garbage Collection Options</title>
  <meta name="TITLE" content="Modron">
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
</head>
<body>
<p></p>
<h1>Modron Garbage Collection Options</h1>
<p></p>
<p>
<b>NOTE:</b> -Xgc: options are private, and subject to change at any
point in the future.
</p>
<p>
</p>
<h2>Option parameter key</h2>
<table border="1">
  <tbody>
    <tr>
      <td>&lt;value&gt;</td>
      <td>integer value</td>
    </tr>
    <tr>
      <td>percent</td>
      <td>integer value in the range of 0--100 (inclusive)</td>
    </tr>
    <tr>
      <td>age</td>
      <td>integer value in the range of 1--14 (inclusive)</td>
    </tr>
    <tr>
      <td>time</td>
      <td>integer value (in milliseconds)</td>
    </tr>
  </tbody>
</table>
<p></p>
<p></p>
<h2>General Garbage Collection Options</h2>
<table border="1">
  <tbody>
    <tr>
      <th>Option</th>
      <th>Effect</th>
    </tr>
    <tr>
      <td rowspan="4">-Xgcpolicy:&lt;option&gt;</td>
      <td><b>optthruput</b>&nbsp;Flat heap (no scavenger, no concurrent
mark)<br>
      </td>
    </tr>
    <tr>
      <td><b>optavgpause</b>&nbsp;Concurrent mark</td>
    </tr>
    <tr>
      <td><b>gencon</b>&nbsp;Scavenger, concurrent mark</td>
    </tr>
    <tr>
      <td><b>subpool</b>&nbsp;Subpool allocator, no scavenger, no
concurrent mark. Only AIX, and S390.</td>
    </tr>
    <tr>
      <td>-Xmx&lt;value&gt;</td>
      <td>Memory maximum (Xmx &gt;= Xms)<br>
scavenger enabled: minimum size 4 kilobytes on 32 bit architectures, 8
kilobytes on 64 bit architectures<br>
scavenger disabled: minimum size 4 kilobytes on 32 bit architectures, 8
kilobytes on 64 bit architectures<br>
      </td>
    </tr>
    <tr>
      <td>-Xresman</td>
      <td>Enable resource managed support</td>
    </tr>
    <tr>
      <td>-Xmdx&lt;value&gt;</td>
      <td>Default memory space maximum size. Xmdx &lt;= Xmx. Ignored if
-Xresman not entered.</td>
    </tr>
    <tr>
      <td>-Xms&lt;value&gt;</td>
      <td>Initial memory size<br>
scavenger enabled: minimum size 4 kilobytes on 32 bit architectures, 8
kilobytes on 64 bit architectures (Xms &gt;= Xmn + Xmo)<br>
scavenger disabled: minimum size 4 kilobytes on 32 bit architectures, 8
kilobytes on 64 bit architectures (Xms &gt;= Xmo)<br>
      </td>
    </tr>
    <tr>
      <td>-Xmos&lt;value&gt;</td>
      <td>Initial old space size, minimum size 512 bytes on 32 bit
architectures, 2048 bytes on 64 bit architectures</td>
    </tr>
    <tr>
      <td>-Xmox&lt;value&gt;</td>
      <td>Maximum old space size</td>
    </tr>
    <tr>
      <td>-Xmo&lt;value&gt;</td>
      <td>Set both Xmos and Xmox - note that attempting to set -Xmo and
-Xmos, or -Xmo and -Xmox will be rejected</td>
    </tr>
    <tr>
      <td>-Xmns&lt;value&gt;</td>
      <td>Initial new space size, minimum size 1024 bytes on 32 bit
architectures, 4096 bytes on 64 bit architectures<br>
scavenger disabled: ignored<br>
      </td>
    </tr>
    <tr>
      <td>-Xmnx&lt;value&gt;</td>
      <td>Maximum new space size<br>
scavenger disabled: ignored<br>
      </td>
    </tr>
    <tr>
      <td>-Xmn&lt;value&gt;</td>
      <td>Set both Xmns and Xmox - note that attempting to set -Xmn and
-Xmns, or
-Xmn and -Xmnx will be rejected<br>
scavenger disabled: ignored<br>
      </td>
    </tr>
    <tr>
      <td>-Xmca&lt;value&gt;</td>
      <td>RAM class segment increment</td>
    </tr>
    <tr>
      <td>-Xmco&lt;value&gt;</td>
      <td>ROM class segment increment</td>
    </tr>
    <tr>
      <td>-Xmoi&lt;value&gt;</td>
      <td>Old space increment. When 0 no old space expansion possible.</td>
    </tr>
    <tr>
      <td>-Xmine&lt;value&gt;</td>
      <td>Heap expansion minimum size</td>
    </tr>
    <tr>
      <td>-Xmaxe&lt;value&gt;</td>
      <td>Heap expansion maximum size</td>
    </tr>
    <tr>
      <td>-Xminf&lt;value&gt;</td>
      <td>Minimum heap percentage free after a garbage collection</td>
    </tr>
    <tr>
      <td>-Xmaxf&lt;value&gt;</td>
      <td>Maximum heap percentage free after a garbage collection</td>
    </tr>
    <tr>
      <td>-Xlp</td>
      <td>Enable large page support</td>
    </tr>
    <tr>
      <td>-Xloa</td>
      <td>Enable large object area support (default)</td>
    </tr>
    <tr>
      <td>-Xnoloa</td>
      <td>Disable large object area support , all objects
are&nbsp;allocated in
SOA</td>
    </tr>
    <tr>
      <td>-Xloainitial&lt;value&gt;</td>
      <td>A floating point value between 0 and 0.95, which specifies
the initial percentage&nbsp; tenure space allocated to the LOA.
The&nbsp;default is 0.05, or 5%. </td>
    </tr>
    <tr>
      <td>-Xloamaximum&lt;value&gt;</td>
      <td>A floating point value between 0 and 0.95,&nbsp;which
specifies the maximum percentage of&nbsp; tenure space allocated to the
LOA. The default is 0.5, or 50%.</td>
    </tr>
    <tr>
      <td>-Xgcthreads&lt;value&gt;</td>
      <td>Number of threads used for garbage collection - <value> must
be &gt; 0</value></td>
    </tr>
    <tr>
      <td>-Xgcworkpackets&lt;value&gt;</td>
      <td>Number of workpackets used during marking - will be rounded
down to be a multiple of 5 and at least 20</td>
    </tr>
    <tr>
      <td>-Xnoclassgc</td>
      <td>Disable dynamic class unloading</td>
    </tr>
    <tr>
      <td>-Xclassgc</td>
      <td>Dynamic class unloading only on class loader changes (default)</td>
    </tr>
    <tr>
      <td>-Xalwaysclassgc</td>
      <td>Always perform dynamic class unloading checks during global
collection</td>
    </tr>
    <tr>
      <td>-Xenablestringconstantgc</td>
      <td>Collect strings from the interned string table</td>
    </tr>
    <tr>
      <td>-Xdisablestringconstantgc</td>
      <td>Never collect strings from the interned string table</td>
    </tr>
    <tr>
      <td>-Xenableexcessivegc</td>
      <td>Throw out-of-memory if excessive time is spent in GC (default)</td>
    </tr>
    <tr>
      <td>-Xdisableexcessivegc</td>
      <td>Do not throw out-of-memory if excessive time is spent in GC</td>
    </tr>
    <tr>
      <td>-Xsoftrefthreshold&lt;value&gt;</td>
      <td>Number of GC's after which a soft reference will be cleared
if&nbsp; its referent has not been marked.&nbsp; The default is 32,.</td>
    </tr>
    <tr>
      <td><b>-Xgc:&lt;option&gt;,&lt;option&gt;,...</b></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;tlhInitialSize=&lt;value&gt;</td>
      <td>Starting TLH size for threads</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;tlhMinimumSize=&lt;value&gt;</td>
      <td>Minimum size to be a candidate for the free list (minimum 512
bytes on 32 bit architectures, 1024 on 64 bit architectures)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;tlhMaximumSize=&lt;value&gt;</td>
      <td>Maximum allowable TLH size for a Thread</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;tlhIncrementSize=&lt;value&gt;</td>
      <td>Size a TLH request increases after a successful refresh</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;version</td>
      <td>Dump internal GC version information</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;batchClearTLH</td>
      <td>Enable batch clear TLH</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;jniArrayCacheMax=&lt;value&gt;</td>
      <td>Maximum size of a JNI cached array (used for copying on
getArrayElements type operations; the cache depth is 1).<br>
value= unlimited or &gt;= 0; 0 disables the array cache<br>
      </td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;finInc=&lt;value&gt;</td>
      <td>Finalize list size increment</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;finMax=&lt;value&gt;</td>
      <td>Finalize list size maximum</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;finInterval=&lt;time&gt;</td>
      <td>Time between objects processed for finalization.<br>
time=nodelay or &gt;= 0; 0 equivalent of a yield()<br>
      </td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;disablesubpoollargeheap</td>
      <td> Useful for configurations with not very high heap free
percentage. Only makes sense with subpool policy. </td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;microFragmentationDetection</td>
      <td> Detects heap fragmentation on sub-minimumFreeEntry size
(512bytes). Works only with subpool policy. </td>
    </tr>
  </tbody>
</table>
<p></p>
<p>
</p>
<h2>Scavenger Options</h2>
<table border="1">
  <tbody>
    <tr>
      <th>Option</th>
      <th>Effect</th>
    </tr>
    <tr>
      <td>-Xmr&lt;value&gt;</td>
      <td>Remembered set size</td>
    </tr>
    <tr>
      <td>-Xmrx&lt;value&gt;</td>
      <td>Remembered set maximum size</td>
    </tr>
    <tr>
      <td><b>-Xgc:&lt;option&gt;,&lt;option&gt;,...</b></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;scavenge</td>
      <td>Enable the scavenger</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;noScavenge</td>
      <td>Disable the scavenger (write barrier checks will still occur
in the VM)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;failedTenureThreshold=&lt;value&gt;</td>
      <td>Maximum number of bytes that can fail tenuring before a
global GC will be triggered in place of the next scavenge (default is
none)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;maxScavengeBeforeGlobal=&lt;value&gt;</td>
      <td>Number of scavenges prior to a global garbage collect being
invoked (default is none)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;adaptiveTenure</td>
      <td>Enable adaptive tenuring (default)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;noAdaptiveTenure</td>
      <td>Disable adaptive tenuring - no tenure age adjustments will
occur</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;tenureAge=&lt;value&gt;</td>
      <td>Age at which an object should be tenured. Default is 10.<br>
All objects are allocated with an age of 0. For every scavenge, a
surviving objects age is increased by 1. If the age of the object hits
the tenure threshold, it is copied to old space instead of the survivor
semi space.<br>
      </td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;scvth=&lt;percent&gt;</td>
      <td>High threshold of new space used after a scavenge to decrease
the tenure age by 1. Default is 30</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;scvtl=&lt;percent&gt;</td>
      <td>Low threshold of a new space used after a scavenge to
increase the tenure age by 1. Default is 10</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;tiltedScavenge</td>
      <td>Enable tilted scavenger (default)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;debugTiltedScavenge</td>
      <td>Enable tracing in tilted scavenger (default disabled)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;noTiltedScavenge</td>
      <td>Disable tilted scavenger</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;tiltedScavengeMinimumRatio=&lt;percent&gt;</td>
      <td>The minimum ratio the survivor space size will have with
respect to the total new space size (used in conjunction with
tiltedScavenge). Valid percentages are 1-99.</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;dynamicNewSpaceSizing</td>
      <td>Enable dynamic new space sizing (default)</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;noDynamicNewSpaceSizing</td>
      <td>Disable dynamic new space sizing</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;debugDynamicNewSpaceSizing</td>
      <td>Enable tracing in dynamic new space sizing (default disabled)</td>
    </tr>
  </tbody>
</table>
<p></p>
<p>
</p>
<h2>Compact Options</h2>
<table border="1">
  <tbody>
    <tr>
      <th>Option</th>
      <th>Effect</th>
    </tr>
    <tr>
      <td>-Xnocompactexplicitgc</td>
      <td>Do not compact on system garbage collects. Compaction will
take place on global garabage collections if -Xcompactgc specified or
compactrion triggers met.</td>
    </tr>
    <tr>
      <td>-Xcompactexplicitgc</td>
      <td>Compact on all system garbage collect. Compaction will take
place on global garabage collections if -Xcompactgc specified or
compactrion triggers met.</td>
    </tr>
    <tr>
      <td>-Xcompactgc</td>
      <td>Compact on all garbage collect (system and global).</td>
    </tr>
    <tr>
      <td>-Xnocompactgc</td>
      <td>Disable compaction on all garnage collections (system or
global).</td>
    </tr>
  </tbody>
</table>
<p></p>
<p>
</p>
<h2>Concurrent Options</h2>
<table border="1">
  <tbody>
    <tr>
      <th>Option</th>
      <th>Effect</th>
    </tr>
    <tr>
      <td><b>-Xgc:&lt;option&gt;,&lt;option&gt;,...</b></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;concurrentMark</td>
      <td>Enable concurrent mark (default disabled) (DEPRECATED? - this
will depend on what the policy names really mean in the end) </td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp;concurrentRASChecks</td>
      <td>Enable concurrent RAS checks (default disabled)</td>
    </tr>
    <tr>
      <td>-Xconcurrentbackground&lt;value&gt;</td>
      <td>The number of low priority background&nbsp; threads attached
to assist the mutator threads in concurrent mark.&nbsp; The default is
1.</td>
    </tr>
    <tr>
      <td>-Xconcurrentlevel&lt;value&gt;</td>
      <td>The allocation "tax" rate, i.e the ratio between the amount
of heap allocated and the amount of heap marked.&nbsp; The default is 8.</td>
    </tr>
    <tr>
      <td colspan="1" rowspan="3">-Xconmeter:&lt;option&gt;</td>
      <td><span style="font-weight: bold;">soa </span>Meter SOA
usage;&nbsp;only&nbsp;allocations in the SOA are taxed.&nbsp;<span
 style="font-weight: bold;"> </span><br>
      </td>
    </tr>
    <tr>
      <td><span style="font-weight: bold;">loa</span>
&nbsp;Meter&nbsp;LOA usage; only&nbsp;allocations in the&nbsp;LOA are
taxed.</td>
    </tr>
    <tr>
      <td><span style="font-weight: bold;">dynamic &nbsp;</span>The
collector dynamically determines which area to meter based on which
area is being exhausted first, be it the SOA or the LOA, and applies
the allocation tax accordingly.</td>
    </tr>
  </tbody>
</table>
<p></p>
<p>
</p>
<h2>Trace GC Options (Xtgc:)</h2>
These traces are similar to those provided by Sovereign's -Xtgc option
(for more information, see <a
 href="http://www-106.ibm.com/developerworks/java/jdk/diagnosis/">here</a>).<br>
<b>Format</b>&nbsp;-Xtgc:&lt;option&gt;,&lt;option&gt;,...
<table border="1">
  <tbody>
    <tr>
      <th>Option</th>
      <th>Effect</th>
    </tr>
    <tr>
      <td>backtrace</td>
      <td>Before a garbage collection, a single line is printed
containing the name of the master thread for garbage collection, as
well as the value of the osThread slot in its J9VMThread structure</td>
    </tr>
    <tr>
      <td>compaction</td>
      <td>Prints extra information showing the relative time spent by
threads in the move and fixup phases of compaction</td>
    </tr>
    <tr>
      <td>concurrent</td>
      <td>Prints extra information showing the activity of the
concurrent mark background thread</td>
    </tr>
    <tr>
      <td>dump</td>
      <td>Similar to terse, prints a line of output for every free
chunk in the system, including dark matter (free chunks that are not on
the free list for some reason, usually because they are too small).
Each line contains the base address and the size in bytes of the chunk.
If the chunk is followed in the heap by an object, the size and class
name of the object is also printed.</td>
    </tr>
    <tr>
      <td>freeList</td>
      <td>Before a garbage collection, prints information about the
free list and allocation statistics since the last GC. Prints the
number of items on the free list, including "deferred" entries (with
the scavenger, the unused semispace is a deferred free list entry). For
TLH and non-TLH allocations, prints the total number of allocations,
the average allocation size, and the total number of bytes discarded in
during allocation. For non-TLH allocations, also included is the
average number of entries that were searched before a sufficiently
large entry was found.</td>
    </tr>
    <tr>
      <td>parallel</td>
      <td>Produces statistics on the activity of the parallel threads
during the mark and sweep phases of a global GC.</td>
    </tr>
    <tr>
      <td>references</td>
      <td>Prints extra information every time a reference object is
enqueued for finalisation, showing the reference type, reference
address, and referent address</td>
    </tr>
    <tr>
      <td>scavenger</td>
      <td>Prints extra information following each scavenger collection.
A histogram is produced showing the number of instances of each class
(and their relative ages) present in the survivor space. The space is
linearly walked to achieve this.</td>
    </tr>
    <tr>
      <td>terse</td>
      <td>Dumps the contents of the entire heap before and after a
garbage collection. For each object or free chunk in the heap, a line
of trace output is produced. Each line contains the base address, "a"
if it is an allocated object and "f" if it is a free chunk, the size of
the chunk in bytes, and if it is an object, its class name.</td>
    </tr>
  </tbody>
</table>
<p></p>
<p>
</p>
<h2>Deprecated Options</h2>
The following options have been removed and replaced with new values.
<p></p>
</body>
</html>
